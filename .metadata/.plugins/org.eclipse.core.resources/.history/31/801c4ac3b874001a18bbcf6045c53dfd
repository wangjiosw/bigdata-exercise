package com.bjsxt.wc2;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.mapreduce.Job;

public class MyReadWriteJob {

	public static void main(String[] args) {
		Configuration config = HBaseConfiguration.create();
		Job job = new Job(config,"ExampleReadWrite");
		job.setJarByClass(MyReadWriteJob.class);    // class that contains mapper

		Scan scan = new Scan();
		scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
		scan.setCacheBlocks(false);  // don't set to true for MR jobs
		// set other scan attrs

		TableMapReduceUtil.initTableMapperJob(
		  sourceTable,      // input table
		  scan,             // Scan instance to control CF and attribute selection
		  MyMapper.class,   // mapper class
		  null,             // mapper output key
		  null,             // mapper output value
		  job);
		TableMapReduceUtil.initTableReducerJob(
		  targetTable,      // output table
		  null,             // reducer class
		  job);
		job.setNumReduceTasks(0);

		boolean b = job.waitForCompletion(true);
		if (!b) {
		    throw new IOException("error with job!");
		}
		An explanation is required of what TableMapReduceUtil is doing, especially with the reducer. TableOutputFormat is being used as the outputFormat class, and several parameters are being set on the config (e.g., TableOutputFormat.OUTPUT_TABLE), as well as setting the reducer output key to ImmutableBytesWritable and reducer value to Writable. These could be set by the programmer on the job and conf, but TableMapReduceUtil tries to make things easier.

		The following is the example mapper, which will create a Put and matching the input Result and emit it. Note: this is what the CopyTable utility does.

		public static class MyMapper extends TableMapper<ImmutableBytesWritable, Put>  {

		  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
		    // this example is just copying the data from the source table...
		      context.write(row, resultToPut(row,value));
		    }

		    private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {
		      Put put = new Put(key.get());
		      for (Cell cell : result.listCells()) {
		        put.add(cell);
		      }
		      return put;
		    }
		}
	}
}
